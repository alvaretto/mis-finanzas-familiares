// üèÉ‚Äç‚ôÇÔ∏è SISTEMA DE EJECUCI√ìN DE TESTS
// Runner autom√°tico y manual para todas las pruebas

class TestRunner {
    constructor() {
        this.testFramework = null;
        this.isRunning = false;
        this.currentRun = null;
        this.scheduledRuns = [];
        this.config = {
            autoRun: false,
            interval: 300000, // 5 minutos
            onFailure: 'notify',
            maxRetries: 3,
            parallel: false,
            coverage: true,
            performance: true,
            generateReport: true
        };
        
        console.log('üèÉ‚Äç‚ôÇÔ∏è Test Runner inicializado');
    }

    // üöÄ Inicializar con framework de testing
    initialize(testFramework) {
        this.testFramework = testFramework;
        console.log('‚úÖ Test Runner conectado al framework');
        
        // Configurar ejecuci√≥n autom√°tica si est√° habilitada
        if (this.config.autoRun) {
            this.scheduleAutomaticRuns();
        }
    }

    // ‚ñ∂Ô∏è Ejecutar todas las pruebas manualmente
    async runAllTests(options = {}) {
        if (this.isRunning) {
            console.warn('‚ö†Ô∏è Ya hay una ejecuci√≥n de tests en progreso');
            return this.currentRun;
        }

        console.log('üöÄ Iniciando ejecuci√≥n manual de todas las pruebas...');
        this.isRunning = true;
        
        const runConfig = { ...this.config, ...options };
        const startTime = performance.now();
        
        try {
            // Crear registro de ejecuci√≥n
            this.currentRun = {
                id: this.generateRunId(),
                type: 'manual',
                startTime: new Date().toISOString(),
                config: runConfig,
                results: null,
                duration: 0,
                status: 'running'
            };

            // Pre-ejecuci√≥n: Verificar estado del sistema
            await this.preRunChecks();

            // Ejecutar tests
            const results = await this.testFramework.runAllTests();
            
            // Post-ejecuci√≥n: Generar reportes
            await this.postRunActions(results, runConfig);
            
            const endTime = performance.now();
            this.currentRun.duration = endTime - startTime;
            this.currentRun.results = results;
            this.currentRun.status = results.failed > 0 ? 'failed' : 'passed';
            this.currentRun.endTime = new Date().toISOString();
            
            console.log(`‚úÖ Ejecuci√≥n completada en ${this.currentRun.duration.toFixed(2)}ms`);
            
            // Notificar resultados
            this.notifyResults(this.currentRun);
            
            return this.currentRun;
            
        } catch (error) {
            console.error('‚ùå Error durante ejecuci√≥n de tests:', error);
            
            if (this.currentRun) {
                this.currentRun.status = 'error';
                this.currentRun.error = error.message;
                this.currentRun.endTime = new Date().toISOString();
            }
            
            throw error;
        } finally {
            this.isRunning = false;
        }
    }

    // üîÑ Ejecutar suite espec√≠fica
    async runSuite(suiteName, options = {}) {
        if (!this.testFramework.suites.has(suiteName)) {
            throw new Error(`Suite "${suiteName}" no encontrada`);
        }

        console.log(`üîÑ Ejecutando suite: ${suiteName}`);
        
        const suite = this.testFramework.suites.get(suiteName);
        const results = await this.testFramework.runSuite(suite);
        
        console.log(`‚úÖ Suite ${suiteName} completada`);
        return results;
    }

    // üß™ Ejecutar test espec√≠fico
    async runTest(testName, options = {}) {
        const testKey = Object.keys(this.testFramework.tests).find(key => 
            key.includes(testName)
        );
        
        if (!testKey) {
            throw new Error(`Test "${testName}" no encontrado`);
        }

        console.log(`üß™ Ejecutando test: ${testName}`);
        
        const test = this.testFramework.tests.get(testKey);
        const suite = this.testFramework.suites.get(test.suite);
        
        await this.testFramework.runTest(test, suite);
        
        console.log(`‚úÖ Test ${testName} completado`);
        return test;
    }

    // ‚è∞ Programar ejecuciones autom√°ticas
    scheduleAutomaticRuns() {
        console.log(`‚è∞ Programando ejecuciones autom√°ticas cada ${this.config.interval}ms`);
        
        const intervalId = setInterval(async () => {
            try {
                console.log('ü§ñ Ejecutando tests autom√°ticos programados...');
                await this.runAllTests({ type: 'automatic' });
            } catch (error) {
                console.error('‚ùå Error en ejecuci√≥n autom√°tica:', error);
            }
        }, this.config.interval);
        
        this.scheduledRuns.push(intervalId);
    }

    // üõë Detener ejecuciones autom√°ticas
    stopAutomaticRuns() {
        this.scheduledRuns.forEach(intervalId => {
            clearInterval(intervalId);
        });
        this.scheduledRuns = [];
        console.log('üõë Ejecuciones autom√°ticas detenidas');
    }

    // üîç Verificaciones pre-ejecuci√≥n
    async preRunChecks() {
        console.log('üîç Ejecutando verificaciones pre-ejecuci√≥n...');
        
        const checks = {
            firebase: typeof firebase !== 'undefined',
            testFramework: !!this.testFramework,
            dom: !!document.getElementById('app'),
            dependencies: this.checkDependencies()
        };
        
        const failedChecks = Object.entries(checks)
            .filter(([key, value]) => !value)
            .map(([key]) => key);
        
        if (failedChecks.length > 0) {
            console.warn('‚ö†Ô∏è Verificaciones fallidas:', failedChecks);
        }
        
        return checks;
    }

    // üì¶ Verificar dependencias
    checkDependencies() {
        const dependencies = [
            'firebase',
            'lucide',
            'Chart',
            'expect',
            'TestingFramework'
        ];
        
        return dependencies.every(dep => typeof window[dep] !== 'undefined');
    }

    // üìä Acciones post-ejecuci√≥n
    async postRunActions(results, config) {
        console.log('üìä Ejecutando acciones post-ejecuci√≥n...');
        
        // Generar reporte HTML si est√° configurado
        if (config.generateReport) {
            this.testFramework.saveHTMLReport();
        }
        
        // Enviar m√©tricas de rendimiento
        if (config.performance) {
            this.collectPerformanceMetrics(results);
        }
        
        // Limpiar recursos si es necesario
        await this.cleanup();
    }

    // üìà Recopilar m√©tricas de rendimiento
    collectPerformanceMetrics(results) {
        const metrics = {
            timestamp: new Date().toISOString(),
            totalTests: results.total,
            passRate: results.total > 0 ? (results.passed / results.total * 100) : 0,
            averageTestDuration: this.calculateAverageTestDuration(),
            memoryUsage: this.getMemoryUsage(),
            browserInfo: this.getBrowserInfo()
        };
        
        console.log('üìà M√©tricas de rendimiento:', metrics);
        
        // Guardar m√©tricas en localStorage para an√°lisis hist√≥rico
        this.saveMetrics(metrics);
        
        return metrics;
    }

    // ‚è±Ô∏è Calcular duraci√≥n promedio de tests
    calculateAverageTestDuration() {
        const tests = Array.from(this.testFramework.tests.values());
        const totalDuration = tests.reduce((sum, test) => sum + (test.duration || 0), 0);
        return tests.length > 0 ? totalDuration / tests.length : 0;
    }

    // üíæ Obtener uso de memoria
    getMemoryUsage() {
        if (window.performance && window.performance.memory) {
            return {
                used: window.performance.memory.usedJSHeapSize,
                total: window.performance.memory.totalJSHeapSize,
                limit: window.performance.memory.jsHeapSizeLimit
            };
        }
        return null;
    }

    // üåê Obtener informaci√≥n del navegador
    getBrowserInfo() {
        return {
            userAgent: navigator.userAgent,
            language: navigator.language,
            platform: navigator.platform,
            cookieEnabled: navigator.cookieEnabled,
            onLine: navigator.onLine
        };
    }

    // üíæ Guardar m√©tricas hist√≥ricas
    saveMetrics(metrics) {
        try {
            const existingMetrics = JSON.parse(localStorage.getItem('testMetrics') || '[]');
            existingMetrics.push(metrics);
            
            // Mantener solo las √∫ltimas 100 m√©tricas
            if (existingMetrics.length > 100) {
                existingMetrics.splice(0, existingMetrics.length - 100);
            }
            
            localStorage.setItem('testMetrics', JSON.stringify(existingMetrics));
        } catch (error) {
            console.warn('‚ö†Ô∏è No se pudieron guardar las m√©tricas:', error);
        }
    }

    // üìä Obtener m√©tricas hist√≥ricas
    getHistoricalMetrics() {
        try {
            return JSON.parse(localStorage.getItem('testMetrics') || '[]');
        } catch (error) {
            console.warn('‚ö†Ô∏è No se pudieron cargar las m√©tricas hist√≥ricas:', error);
            return [];
        }
    }

    // üîî Notificar resultados
    notifyResults(run) {
        const { results } = run;
        
        if (results.failed > 0) {
            console.error(`‚ùå ${results.failed} tests fallaron de ${results.total}`);
            
            if (this.config.onFailure === 'notify' && 'Notification' in window) {
                this.showNotification('Tests Fallaron', `${results.failed} de ${results.total} tests fallaron`);
            }
        } else {
            console.log(`‚úÖ Todos los tests pasaron (${results.total}/${results.total})`);
            
            if ('Notification' in window) {
                this.showNotification('Tests Exitosos', `Todos los ${results.total} tests pasaron`);
            }
        }
    }

    // üîî Mostrar notificaci√≥n del navegador
    showNotification(title, message) {
        if (Notification.permission === 'granted') {
            new Notification(title, {
                body: message,
                icon: '/favicon.ico'
            });
        } else if (Notification.permission !== 'denied') {
            Notification.requestPermission().then(permission => {
                if (permission === 'granted') {
                    new Notification(title, {
                        body: message,
                        icon: '/favicon.ico'
                    });
                }
            });
        }
    }

    // üßπ Limpiar recursos
    async cleanup() {
        // Limpiar cualquier recurso temporal creado durante los tests
        console.log('üßπ Limpiando recursos de testing...');
        
        // Remover elementos DOM temporales
        const tempElements = document.querySelectorAll('[data-test-temp]');
        tempElements.forEach(element => element.remove());
        
        // Limpiar timers si los hay
        // (Los timers espec√≠ficos se limpiar√≠an aqu√≠)
    }

    // üÜî Generar ID √∫nico para ejecuci√≥n
    generateRunId() {
        return 'run-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
    }

    // ‚öôÔ∏è Actualizar configuraci√≥n
    updateConfig(newConfig) {
        this.config = { ...this.config, ...newConfig };
        console.log('‚öôÔ∏è Configuraci√≥n actualizada:', this.config);
        
        // Reconfigurar ejecuciones autom√°ticas si es necesario
        if (newConfig.autoRun !== undefined) {
            if (newConfig.autoRun) {
                this.scheduleAutomaticRuns();
            } else {
                this.stopAutomaticRuns();
            }
        }
    }

    // üìä Obtener estado actual
    getStatus() {
        return {
            isRunning: this.isRunning,
            currentRun: this.currentRun,
            config: this.config,
            scheduledRuns: this.scheduledRuns.length,
            historicalMetrics: this.getHistoricalMetrics().length
        };
    }
}

// üåê Exportar para uso global
window.TestRunner = TestRunner;
